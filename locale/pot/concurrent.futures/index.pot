# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-15 15:56-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/concurrent.futures/index.rst:3
msgid "concurrent.futures --- Manage Pools of Concurrent Tasks"
msgstr ""

#: ../../source/concurrent.futures/index.rst:8
msgid "Easily manage tasks running concurrently and in parallel."
msgstr ""

#: ../../source/concurrent.futures/index.rst:10
msgid "The ``concurrent.futures`` modules provides interfaces for running tasks using pools of thread or process workers. The APIs are the same, so applications can switch between threads and processes with minimal changes."
msgstr ""

#: ../../source/concurrent.futures/index.rst:15
msgid "The module provides two types of classes for interacting with the pools. *Executors* are used for managing pools of workers, and *futures* are used for managing results computed by the workers. To use a pool of workers, an application creates an instance of the appropriate executor class and then submits tasks for it to run. When each task is started, a ``Future`` instance is returned. When the result of the task is needed, an application can use the ``Future`` to block until the result is available. Various APIs are provided to make it convenient to wait for tasks to complete, so that the ``Future`` objects do not need to be managed directly."
msgstr ""

#: ../../source/concurrent.futures/index.rst:27
msgid "Using map() with a Basic Thread Pool"
msgstr ""

#: ../../source/concurrent.futures/index.rst:29
msgid "The ``ThreadPoolExecutor`` manages a set of worker threads, passing tasks to them as they become available for more work. This example uses ``map()`` to concurrently produce a set of results from an input iterable.  The task uses ``time.sleep()`` to pause a different amount of time to demonstrate that, regardless of the order of execution of concurrent tasks, ``map()`` always returns the values in order based on the inputs."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_thread_pool_map.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:41
msgid "The return value from ``map()`` is actually a special type of iterator that knows to wait for each response as the main program iterates over it."
msgstr ""

#: ../../source/concurrent.futures/index.rst:72
msgid "Scheduling Individual Tasks"
msgstr ""

#: ../../source/concurrent.futures/index.rst:74
msgid "In addition to using ``map()``, it is possible to schedule an individual task with an executor using ``submit()``, and use the ``Future`` instance returned to wait for that task's results."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_thread_pool_submit.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:82
msgid "The status of the future changes after the tasks is completed and the result is made available."
msgstr ""

#: ../../source/concurrent.futures/index.rst:105
msgid "Waiting for Tasks in Any Order"
msgstr ""

#: ../../source/concurrent.futures/index.rst:107
msgid "Invoking the ``result()`` method of a ``Future`` blocks until the task completes (either by returning a value or raising an exception), or is canceled. The results of multiple tasks can be accessed in the order the tasks were scheduled using ``map()``. If it does not matter what order the results should be processed, use ``as_completed()`` to process them as each task finishes."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_as_completed.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:118
msgid "Because the pool has as many workers as tasks, all of the tasks can be started. They finish in a random order so the values generated by ``as_completed()`` are different each time the example runs."
msgstr ""

#: ../../source/concurrent.futures/index.rst:140
msgid "Future Callbacks"
msgstr ""

#: ../../source/concurrent.futures/index.rst:142
msgid "To take some action when a task completed, without explicitly waiting for the result, use ``add_done_callback()`` to specify a new function to call when the ``Future`` is done. The callback should be a callable taking a single argument, the ``Future`` instance."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_future_callback.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:151
msgid "The callback is invoked regardless of the reason the ``Future`` is considered \"done,\" so it is necessary to check the status of the object passed in to the callback before using it in any way."
msgstr ""

#: ../../source/concurrent.futures/index.rst:171
msgid "Canceling Tasks"
msgstr ""

#: ../../source/concurrent.futures/index.rst:173
msgid "A ``Future`` can be canceled, if it has been submitted but not started, by calling its ``cancel()`` method."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_future_callback_cancel.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:180
msgid "``cancel()`` returns a Boolean indicating whether or not the task was able to be canceled."
msgstr ""

#: ../../source/concurrent.futures/index.rst:222
msgid "Exceptions in Tasks"
msgstr ""

#: ../../source/concurrent.futures/index.rst:224
msgid "If a task raises an unhandled exception, it is saved to the ``Future`` for the task and made available through the ``result()`` or ``exception()`` methods."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_future_exception.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:232
msgid "If ``result()`` is called after an unhandled exception is raised within a task function, the same exception is re-raised in the current context."
msgstr ""

#: ../../source/concurrent.futures/index.rst:252
msgid "Context Manager"
msgstr ""

#: ../../source/concurrent.futures/index.rst:254
msgid "Executors work as context managers, running tasks concurrently and waiting for them all to complete. When the context manager exits, the ``shutdown()`` method of the executor is called."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_context_manager.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:262
msgid "This mode of using the executor is useful when the thread or process resources should be cleaned up when execution leaves the current scope."
msgstr ""

#: ../../source/concurrent.futures/index.rst:284
msgid "Process Pools"
msgstr ""

#: ../../source/concurrent.futures/index.rst:286
msgid "The ``ProcessPoolExecutor`` works in the same way as ``ThreadPoolExecutor``, but uses processes instead of threads. This allows CPU-intensive operations to use a separate CPU and not be blocked by the CPython interpreter's global interpreter lock."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_process_pool_map.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:296
msgid "As with the thread pool, individual worker processes are reused for multiple tasks."
msgstr ""

#: ../../source/concurrent.futures/index.rst:315
msgid "If something happens to one of the worker processes to cause it to exit unexpectedly, the ``ProcessPoolExecutor`` is considered \"broken\" and will no longer schedule tasks."
msgstr ""

#: ../../source/concurrent.futures/index.rst:0
msgid "futures_process_pool_broken.py"
msgstr ""

#: ../../source/concurrent.futures/index.rst:323
msgid "The ``BrokenProcessPool`` exception is actually thrown when the results are processed, rather than when the new task is submitted."
msgstr ""

#: ../../source/concurrent.futures/index.rst:346
msgid ":pydoc:`concurrent.futures`"
msgstr ""

#: ../../source/concurrent.futures/index.rst:348
msgid ":pep:`3148` -- The proposal for creating the ``concurrent.futures`` feature set."
msgstr ""

#: ../../source/concurrent.futures/index.rst:351
msgid ":ref:`asyncio-executors`"
msgstr ""

#: ../../source/concurrent.futures/index.rst:353
msgid ":mod:`threading`"
msgstr ""

#: ../../source/concurrent.futures/index.rst:355
msgid ":mod:`multiprocessing`"
msgstr ""

