# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-15 15:56-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/signal/index.rst:3
msgid "signal --- Asynchronous System Events"
msgstr ""

#: ../../source/signal/index.rst:8
msgid "Asynchronous system events"
msgstr ""

#: ../../source/signal/index.rst:10
msgid "Signals are an operating system feature that provide a means of notifying a program of an event, and having it handled asynchronously. They can be generated by the system itself, or sent from one process to another.  Since signals interrupt the regular flow of the program, it is possible that some operations (especially I/O) may produce errors if a signal is received in the middle."
msgstr ""

#: ../../source/signal/index.rst:17
msgid "Signals are identified by integers and are defined in the operating system C headers.  Python exposes the signals appropriate for the platform as symbols in the ``signal`` module.  The examples in this section use ``SIGINT`` and ``SIGUSR1``.  Both are typically defined for all Unix and Unix-like systems."
msgstr ""

#: ../../source/signal/index.rst:25
msgid "Programming with Unix signal handlers is a non-trivial endeavor. This is an introduction, and does not include all of the details needed to use signals successfully on every platform. There is some degree of standardization across versions of Unix, but there is also some variation, so consult the operating system documentation if you run into trouble."
msgstr ""

#: ../../source/signal/index.rst:33
msgid "Receiving Signals"
msgstr ""

#: ../../source/signal/index.rst:35
msgid "As with other forms of event-based programming, signals are received by establishing a callback function, called a *signal handler*, that is invoked when the signal occurs.  The arguments to the signal handler are the signal number and the stack frame from the point in the program that was interrupted by the signal."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_signal.py"
msgstr ""

#: ../../source/signal/index.rst:45
msgid "This example script loops indefinitely, pausing for a few seconds each time.  When a signal comes in, the ``sleep()`` call is interrupted and the signal handler ``receive_signal`` prints the signal number. After the signal handler returns, the loop continues."
msgstr ""

#: ../../source/signal/index.rst:50
msgid "Send signals to the running program using ``os.kill()`` or the Unix command line program ``kill``."
msgstr ""

#: ../../source/signal/index.rst:74
msgid "The previous output was produced by running ``signal_signal.py`` in one window, then in another window running:"
msgstr ""

#: ../../source/signal/index.rst:87
msgid "Retrieving Registered Handlers"
msgstr ""

#: ../../source/signal/index.rst:89
msgid "To see what signal handlers are registered for a signal, use ``getsignal()``.  Pass the signal number as argument.  The return value is the registered handler, or one of the special values ``SIG_IGN`` (if the signal is being ignored), ``SIG_DFL`` (if the default behavior is being used), or ``None`` (if the existing signal handler was registered from C, rather than Python)."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_getsignal.py"
msgstr ""

#: ../../source/signal/index.rst:100
msgid "Again, since each OS may have different signals defined, the output on other systems may vary.  This is from OS X:"
msgstr ""

#: ../../source/signal/index.rst:147
msgid "Sending Signals"
msgstr ""

#: ../../source/signal/index.rst:149
msgid "The function for sending signals from within Python is ``os.kill()``.  Its use is covered in the section on the :mod:`os` module, :ref:`creating-processes-with-os-fork`."
msgstr ""

#: ../../source/signal/index.rst:154
msgid "Alarms"
msgstr ""

#: ../../source/signal/index.rst:156
msgid "Alarms are a special sort of signal, where the program asks the OS to notify it after some period of time has elapsed.  As the standard module documentation for :mod:`os` points out, this is useful for avoiding blocking indefinitely on an I/O operation or other system call."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_alarm.py"
msgstr ""

#: ../../source/signal/index.rst:165
msgid "In this example, the call to ``sleep()`` is interrupted, but then continues after the signal is processed so the message printed after ``sleep()`` returns shows that the program was paused for at least as long as the sleep duration."
msgstr ""

#: ../../source/signal/index.rst:186
msgid "Ignoring Signals"
msgstr ""

#: ../../source/signal/index.rst:188
msgid "To ignore a signal, register ``SIG_IGN`` as the handler.  This script replaces the default handler for ``SIGINT`` with ``SIG_IGN``, and registers a handler for ``SIGUSR1``.  Then it uses ``signal.pause()`` to wait for a signal to be received."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_ignore.py"
msgstr ""

#: ../../source/signal/index.rst:197
msgid "Normally ``SIGINT`` (the signal sent by the shell to a program when the user presses ``Ctrl-C``) raises a ``KeyboardInterrupt``. This example ignores ``SIGINT`` and raises ``SystemExit`` when it sees ``SIGUSR1``.  Each ``^C`` in the output represents an attempt to use ``Ctrl-C`` to kill the script from the terminal. Using ``kill -USR1 72598`` from another terminal eventually causes the script to exit."
msgstr ""

#: ../../source/signal/index.rst:216
msgid "Signals and Threads"
msgstr ""

#: ../../source/signal/index.rst:218
msgid "Signals and threads do not generally mix well because only the main thread of a process will receive signals.  The following example sets up a signal handler, waits for the signal in one thread, and sends the signal from another."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_threads.py"
msgstr ""

#: ../../source/signal/index.rst:227
msgid "The signal handlers were all registered in the main thread because this is a requirement of the ``signal`` module implementation for Python, regardless of underlying platform support for mixing threads and signals.  Although the receiver thread calls ``signal.pause()``, it does not receive the signal.  The ``signal.alarm(2)`` call near the end of the example prevents an infinite block, since the receiver thread will never exit."
msgstr ""

#: ../../source/signal/index.rst:247
msgid "Although alarms can be set in any thread, they are always received by the main thread."
msgstr ""

#: ../../source/signal/index.rst:0
msgid "signal_threads_alarm.py"
msgstr ""

#: ../../source/signal/index.rst:254
msgid "The alarm does not abort the ``sleep()`` call in ``use_alarm()``."
msgstr ""

#: ../../source/signal/index.rst:276
msgid ":pydoc:`signal`"
msgstr ""

#: ../../source/signal/index.rst:278
msgid ":pep:`475` -- Retry system calls failing with EINTR"
msgstr ""

#: ../../source/signal/index.rst:280
msgid ":mod:`subprocess` -- More examples of sending signals to processes."
msgstr ""

#: ../../source/signal/index.rst:283
msgid ":ref:`creating-processes-with-os-fork` -- The ``kill()`` function can be used to send signals between processes."
msgstr ""

