# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-15 15:56-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/multiprocessing/basics.rst:2
msgid "multiprocessing Basics"
msgstr ""

#: ../../source/multiprocessing/basics.rst:4
msgid "The simplest way to spawn a second process is to instantiate a ``Process`` object with a target function and call ``start()`` to let it begin working."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_simple.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:12
msgid "The output includes the word \"Worker\" printed five times, although it may not come out entirely clean, depending on the order of execution, because each process is competing for access to the output stream."
msgstr ""

#: ../../source/multiprocessing/basics.rst:33
msgid "It usually more useful to be able to spawn a process with arguments to tell it what work to do.  Unlike with ``threading``, in order to pass arguments to a ``multiprocessing`` ``Process`` the arguments must be able to be serialized using :mod:`pickle`.  This example passes each worker a number to be printed."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_simpleargs.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:43
msgid "The integer argument is now included in the message printed by each worker."
msgstr ""

#: ../../source/multiprocessing/basics.rst:63
msgid "Importable Target Functions"
msgstr ""

#: ../../source/multiprocessing/basics.rst:65
msgid "One difference between the ``threading`` and ``multiprocessing`` examples is the extra protection for ``__main__`` used in the ``multiprocessing`` examples.  Due to the way the new processes are started, the child process needs to be able to import the script containing the target function.  Wrapping the main part of the application in a check for ``__main__`` ensures that it is not run recursively in each child as the module is imported.  Another approach is to import the target function from a separate script.  For example, ``multiprocessing_import_main.py`` uses a worker function defined in a second module."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_import_main.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:80
msgid "The worker function is defined in ``multiprocessing_import_worker.py``."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_import_worker.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:86
msgid "Calling the main program produces output similar to the first example."
msgstr ""

#: ../../source/multiprocessing/basics.rst:105
msgid "Determining the Current Process"
msgstr ""

#: ../../source/multiprocessing/basics.rst:107
msgid "Passing arguments to identify or name the process is cumbersome, and unnecessary.  Each ``Process`` instance has a name with a default value that can be changed as the process is created. Naming processes is useful for keeping track of them, especially in applications with multiple types of processes running simultaneously."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_names.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:117
msgid "The debug output includes the name of the current process on each line. The lines with ``Process-3`` in the name column correspond to the unnamed process ``worker_1``."
msgstr ""

#: ../../source/multiprocessing/basics.rst:140
msgid "Daemon Processes"
msgstr ""

#: ../../source/multiprocessing/basics.rst:142
msgid "By default, the main program will not exit until all of the children have exited. There are times when starting a background process that runs without blocking the main program from exiting is useful, such as in services where there may not be an easy way to interrupt the worker, or where letting it die in the middle of its work does not lose or corrupt data (for example, a task that generates \"heart beats\" for a service monitoring tool)."
msgstr ""

#: ../../source/multiprocessing/basics.rst:150
msgid "To mark a process as a daemon, set its :attr:`daemon` attribute to ``True``. The default is for processes to not be daemons."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_daemon.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:157
msgid "The output does not include the \"Exiting\" message from the daemon process, since all of the non-daemon processes (including the main program) exit before the daemon process wakes up from its two second sleep."
msgstr ""

#: ../../source/multiprocessing/basics.rst:176
msgid "The daemon process is terminated automatically before the main program exits, which avoids leaving orphaned processes running.  This can be verified by looking for the process id value printed when the program runs, and then checking for that process with a command like ``ps``."
msgstr ""

#: ../../source/multiprocessing/basics.rst:183
msgid "Waiting for Processes"
msgstr ""

#: ../../source/multiprocessing/basics.rst:185
msgid "To wait until a process has completed its work and exited, use the ``join()`` method."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_daemon_join.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:192
msgid "Since the main process waits for the daemon to exit using ``join()``, the \"Exiting\" message is printed this time."
msgstr ""

#: ../../source/multiprocessing/basics.rst:210
msgid "By default, ``join()`` blocks indefinitely. It is also possible to pass a timeout argument (a float representing the number of seconds to wait for the process to become inactive). If the process does not complete within the timeout period, ``join()`` returns anyway."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_daemon_join_timeout.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:219
msgid "Since the timeout passed is less than the amount of time the daemon sleeps, the process is still \"alive\" after ``join()`` returns."
msgstr ""

#: ../../source/multiprocessing/basics.rst:237
msgid "Terminating Processes"
msgstr ""

#: ../../source/multiprocessing/basics.rst:239
msgid "Although it is better to use the *poison pill* method of signaling to a process that it should exit (see :ref:`multiprocessing-queues`, later in this chapter), if a process appears hung or deadlocked it can be useful to be able to kill it forcibly.  Calling ``terminate()`` on a process object kills the child process."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_terminate.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:251
msgid "It is important to ``join()`` the process after terminating it in order to give the process management code time to update the status of the object to reflect the termination."
msgstr ""

#: ../../source/multiprocessing/basics.rst:272
msgid "Process Exit Status"
msgstr ""

#: ../../source/multiprocessing/basics.rst:274
msgid "The status code produced when the process exits can be accessed via the :attr:`exitcode` attribute.  The ranges allowed are listed in :table:`Multiprocessing Exit Codes`."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "Multiprocessing Exit Codes"
msgstr ""

#: ../../source/multiprocessing/basics.rst:281
msgid "Exit Code"
msgstr ""

#: ../../source/multiprocessing/basics.rst:281
msgid "Meaning"
msgstr ""

#: ../../source/multiprocessing/basics.rst:283
msgid "``== 0``"
msgstr ""

#: ../../source/multiprocessing/basics.rst:283
msgid "no error was produced"
msgstr ""

#: ../../source/multiprocessing/basics.rst:284
msgid "``> 0``"
msgstr ""

#: ../../source/multiprocessing/basics.rst:284
msgid "the process had an error, and exited with that code"
msgstr ""

#: ../../source/multiprocessing/basics.rst:285
msgid "``< 0``"
msgstr ""

#: ../../source/multiprocessing/basics.rst:285
msgid "the process was killed with a signal of ``-1 * exitcode``"
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_exitcode.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:292
msgid "Processes that raise an exception automatically get an :attr:`exitcode` of 1."
msgstr ""

#: ../../source/multiprocessing/basics.rst:329
msgid "Logging"
msgstr ""

#: ../../source/multiprocessing/basics.rst:331
msgid "When debugging concurrency issues, it can be useful to have access to the internals of the objects provided by ``multiprocessing``. There is a convenient module-level function to enable logging called ``log_to_stderr()``.  It sets up a logger object using :mod:`logging` and adds a handler so that log messages are sent to the standard error channel."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_log_to_stderr.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:342
msgid "By default, the logging level is set to ``NOTSET`` so no messages are produced.  Pass a different level to initialize the logger to the level of detail desired."
msgstr ""

#: ../../source/multiprocessing/basics.rst:368
msgid "To manipulate the logger directly (change its level setting or add handlers), use ``get_logger()``."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_get_logger.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:375
msgid "The logger can also be configured through the ``logging`` configuration file API, using the name \"``multiprocessing``\"."
msgstr ""

#: ../../source/multiprocessing/basics.rst:396
msgid "Subclassing Process"
msgstr ""

#: ../../source/multiprocessing/basics.rst:398
msgid "Although the simplest way to start a job in a separate process is to use ``Process`` and pass a target function, it is also possible to use a custom subclass."
msgstr ""

#: ../../source/multiprocessing/basics.rst:0
msgid "multiprocessing_subclass.py"
msgstr ""

#: ../../source/multiprocessing/basics.rst:406
msgid "The derived class should override :meth:`run` to do its work."
msgstr ""

