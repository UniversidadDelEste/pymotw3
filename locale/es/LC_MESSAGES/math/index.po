# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 13:35-0300\n"
"PO-Revision-Date: 2015-10-10 11:27-0300\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.5.4\n"
"Language: es\n"

#: ../../PyMOTW/math/index.rst:3
msgid "math -- Mathematical functions"
msgstr "math -- Funciones matemáticas"

# Provide> Provee o proporciona?
#: ../../PyMOTW/math/index.rst:8
msgid "Provides functions for specialized mathematical operations."
msgstr "Provee funciones para operaciones matemáticas especializadas"

#: ../../PyMOTW/math/index.rst:9
msgid "1.4"
msgstr "1.4"

#: ../../PyMOTW/math/index.rst:11
msgid ""
"The ``math`` module implements many of the IEEE functions that would "
"normally be found in the native platform C libraries for complex "
"mathematical operations using floating point values, including logarithms"
" and trigonometric operations."
msgstr ""
"El : mod :`math` módulo implementa muchas de las funciones IEEE que "
"normalmente se pueden encontrar en las plataformas nativas de las "
"bibliotecas C para operaciones matemáticas complejas usando valores punto "
"flotante, incluyendo logaritmos y operaciones trigonométricas."

#: ../../source/math/index.rst:16
msgid "Special Constants"
msgstr "Constantes Especiales"

#: ../../source/math/index.rst:18
msgid ""
"Many math operations depend on special constants.  ``math`` includes "
"values for π (pi), e, nan (not a number), and infinity."
msgstr ""

#: ../../source/math/index.rst
msgid "math_constants.py"
msgstr ""

#: ../../source/math/index.rst:25
msgid ""
"Both values are limited in precision only by the platform's floating point C "
"library."
msgstr ""

#: ../../source/math/index.rst:44
msgid "Testing for Exceptional Values"
msgstr ""

#: ../../source/math/index.rst:46
msgid ""
"Floating point calculations can result in two types of exceptional "
"values.  The first of these, ``inf`` (infinity), appears when the "
"``double`` used to hold a floating point value overflows from a value "
"with a large absolute value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_isinf.py"
msgstr ""

#: ../../source/math/index.rst:55
msgid ""
"When the exponent in this example grows large enough, the square of ``x``"
" no longer fits inside a ``double``, and the value is recorded as "
"infinite."
msgstr ""

#: ../../source/math/index.rst:83
msgid ""
"Not all floating point overflows result in ``INF`` values, however. "
"Calculating an exponent with floating point values, in particular, raises :"
"ref:`OverflowError <exceptions-OverflowError>` instead of preserving the "
"``INF`` result."
msgstr ""

#: ../../source/math/index.rst:92
msgid ""
"This discrepancy is caused by an implementation difference in the library"
" used by C Python."
msgstr ""

#: ../../source/math/index.rst:109
msgid ""
"Division operations using infinite values are undefined.  The result of "
"dividing a number by infinity is ``nan`` (not a number)."
msgstr ""

#: ../../source/math/index.rst
msgid "math_isnan.py"
msgstr ""

#: ../../source/math/index.rst:116
msgid ""
"``nan`` does not compare as equal to any value, even itself, so to check "
"for ``nan`` use ``isnan()``."
msgstr ""

#: ../../source/math/index.rst:135
msgid ""
"Use ``isfinite()`` to check for regular numbers or either of the special "
"values ``inf`` or ``nan``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_isfinite.py"
msgstr ""

#: ../../source/math/index.rst:142
msgid ""
"``isfinite()`` returns false for either of the exceptional cases, and "
"true otherwise."
msgstr ""

#: ../../source/math/index.rst:163
msgid "Comparing"
msgstr ""

#: ../../source/math/index.rst:165
msgid ""
"``NaN`` does not compare as equal to any value, even itself, so to check for "
"``NaN`` you must use :func:`isnan`."
msgstr ""

#: ../../source/math/index.rst:175
#, python-format
msgid ""
"By default, ``isclose()`` uses relative comparison with the tolerance set"
" to ``1e-09``, meaning that the difference between the values must be "
"less than or equal to ``1e-09`` times the larger absolute value between "
"``a`` and ``b``. Passing a keyword argument ``rel_tol`` to ``isclose()`` "
"changes the tolerance. In this example, the values must be within 10% of "
"each other."
msgstr ""

#: ../../source/math/index.rst
msgid "math_isclose.py"
msgstr ""

#: ../../source/math/index.rst:186
msgid ""
"The comparison between ``0.1`` and ``0.09`` fails because of the error "
"representing ``0.1``."
msgstr ""

#: ../../source/math/index.rst:207
msgid ""
"The :mod:`math` module includes three functions for converting floating "
"point values to whole numbers.  Each takes a different approach, and will be "
"useful in different circumstances."
msgstr ""

#: ../../source/math/index.rst:214
msgid ""
"For an absolute tolerance, the difference between the input values must "
"be less than the tolerance given."
msgstr ""

#: ../../source/math/index.rst:233
msgid "``nan`` and ``inf`` are special cases."
msgstr ""

#: ../../source/math/index.rst
msgid "math_isclose_inf.py"
msgstr ""

#: ../../source/math/index.rst:239
msgid ""
"``nan`` is never close to another value, including itself. ``inf`` is "
"only close to itself."
msgstr ""

#: ../../source/math/index.rst:258
msgid "Converting Floating Point Values to Integers"
msgstr ""

#: ../../source/math/index.rst:260
msgid ""
"The ``math`` module includes three functions for converting floating "
"point values to whole numbers.  Each takes a different approach, and will"
" be useful in different circumstances."
msgstr ""

#: ../../source/math/index.rst:264
msgid ""
"The simplest is ``trunc()``, which truncates the digits following the "
"decimal, leaving only the significant digits making up the whole number "
"portion of the value.  ``floor()`` converts its input to the largest "
"preceding integer, and ``ceil()`` (ceiling) produces the largest integer "
"following sequentially after the input value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_integers.py"
msgstr ""

#: ../../source/math/index.rst:274
msgid "``trunc()`` is equivalent to converting to ``int`` directly."
msgstr ""

#: ../../source/math/index.rst:299
msgid "Alternate Representations of Floating Point Values"
msgstr ""

#: ../../source/math/index.rst:301
msgid ""
"``modf()`` takes a single floating point number and returns a tuple "
"containing the fractional and whole number parts of the input value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_modf.py"
msgstr ""

#: ../../source/math/index.rst:308
msgid "Both numbers in the return value are floats."
msgstr ""

#: ../../source/math/index.rst:327
msgid ""
"``frexp()`` returns the mantissa and exponent of a floating point number,"
" and can be used to create a more portable representation of the value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_frexp.py"
msgstr ""

#: ../../source/math/index.rst:335
msgid ""
"``frexp()`` uses the formula ``x = m * 2**e``, and returns the values "
"``m`` and ``e``."
msgstr ""

#: ../../source/math/index.rst:354
msgid "``ldexp()`` is the inverse of ``frexp()``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_ldexp.py"
msgstr ""

#: ../../source/math/index.rst:360
msgid ""
"Using the same formula as ``frexp()``, ``ldexp()`` takes the mantissa and"
" exponent values as arguments and returns a floating point number."
msgstr ""

#: ../../source/math/index.rst:382
msgid "Positive and Negative Signs"
msgstr ""

#: ../../source/math/index.rst:384
msgid ""
"The absolute value of a number is its value without a sign.  Use "
"``fabs()`` to calculate the absolute value of a floating point number."
msgstr ""

#: ../../source/math/index.rst
msgid "math_fabs.py"
msgstr ""

#: ../../source/math/index.rst:392
msgid ""
"In practical terms, the absolute value of a :class:`float` is represented as "
"a positive value."
msgstr ""

#: ../../source/math/index.rst:410
msgid ""
"To determine the sign of a value, either to give a set of values the same"
" sign or to compare two values, use ``copysign()`` to set the sign of a "
"known good value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_copysign.py"
msgstr ""

#: ../../source/math/index.rst:418
msgid ""
"An extra function like :func:`copysign` is needed because comparing NaN and -"
"NaN directly with other values does not work."
msgstr ""

#: ../../source/math/index.rst:442
msgid "Commonly Used Calculations"
msgstr ""

#: ../../source/math/index.rst:444
msgid ""
"Representing precise values in binary floating point memory is challenging.  "
"Some values cannot be represented exactly, and the more often a value is "
"manipulated through repeated calculations, the more likely a representation "
"error will be introduced.  :mod:`math` includes a function for computing the "
"sum of a series of floating point numbers using an efficient algorithm that "
"minimize such errors."
msgstr ""

#: ../../source/math/index.rst
msgid "math_fsum.py"
msgstr ""

#: ../../source/math/index.rst:455
msgid ""
"Given a sequence of ten values each equal to ``0.1``, the expected value for "
"the sum of the sequence is ``1.0``.  Since ``0.1`` cannot be represented "
"exactly as a floating point value, however, errors are introduced into the "
"sum unless it is calculated with :func:`fsum`."
msgstr ""

#: ../../source/math/index.rst:475
msgid ""
"``factorial()`` is commonly used to calculate the number of permutations "
"and combinations of a series of objects.  The factorial of a positive "
"integer ``n``, expressed ``n!``, is defined recursively as ``(n-1)! * n``"
" and stops with ``0! == 1``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_factorial.py"
msgstr ""

#: ../../source/math/index.rst:484
msgid ""
":func:`factorial` only works with whole numbers, but does accept :class:"
"`float` arguments as long as they can be converted to an integer without "
"losing value."
msgstr ""

#: ../../source/math/index.rst:507
msgid ""
"``gamma()`` is like ``factorial()``, except it works with real numbers "
"and the value is shifted down by one (gamma is equal to ``(n - 1)!``)."
msgstr ""

#: ../../source/math/index.rst
msgid "math_gamma.py"
msgstr ""

#: ../../source/math/index.rst:515
msgid "Since zero causes the start value to be negative, it is not allowed."
msgstr ""

#: ../../source/math/index.rst:535
msgid ""
"``lgamma()`` returns the natural logarithm of the absolute value of gamma"
" for the input value."
msgstr ""

#: ../../source/math/index.rst
msgid "math_lgamma.py"
msgstr ""

#: ../../source/math/index.rst:542
msgid ""
"Using ``lgamma()`` retains more precision than calculating the logarithm "
"separately using the results of ``gamma()``."
msgstr ""

#: ../../source/math/index.rst:563
msgid ""
"The modulo operator (``%``) computes the remainder of a division expression "
"(i.e., ``5 % 2 = 1``).  The operator built into the language works well with "
"integers but, as with so many other floating point operations, intermediate "
"calculations cause representational issues that result in a loss of data.  :"
"func:`fmod` provides a more accurate implementation for floating point "
"values."
msgstr ""

#: ../../source/math/index.rst:574
msgid ""
"A potentially more frequent source of confusion is the fact that the "
"algorithm used by ``fmod()`` for computing modulo is also different from "
"that used by ``%``, so the sign of the result is different."
msgstr ""

#: ../../source/math/index.rst:594
msgid ""
"Use ``gcd()`` to find the largest integer that can divide evenly into two"
" integers, the greatest common divisor."
msgstr ""

#: ../../source/math/index.rst
msgid "math_gcd.py"
msgstr ""

#: ../../source/math/index.rst:601
msgid "If both values are ``0``, the result is ``0``."
msgstr ""

#: ../../source/math/index.rst:620
msgid "Exponents and Logarithms"
msgstr ""

#: ../../source/math/index.rst:622
msgid ""
"Exponential growth curves appear in economics, physics, and other sciences.  "
"Python has a built-in exponentiation operator (\"``**``\"), but :func:`pow` "
"can be useful when you need to pass a callable function as an argument."
msgstr ""

#: ../../source/math/index.rst:631
msgid ""
"Raising ``1`` to any power always returns ``1.0``, as does raising any value "
"to a power of ``0.0``.  Most operations on the not-a-number value ``nan`` "
"return ``nan``.  If the exponent is less than ``1``, :func:`pow` computes a "
"root."
msgstr ""

#: ../../source/math/index.rst:654
msgid ""
"Since square roots (exponent of ``1/2``) are used so frequently, there is"
" a separate function for computing them."
msgstr ""

#: ../../source/math/index.rst
msgid "math_sqrt.py"
msgstr ""

#: ../../source/math/index.rst:661
msgid ""
"Computing the square roots of negative numbers requires *complex "
"numbers*, which are not handled by ``math``.  Any attempt to calculate a "
"square root of a negative value results in a ``ValueError``."
msgstr ""

#: ../../source/math/index.rst:680
msgid ""
"The logarithm function finds *y* where ``x = b ** y``.  By default, :func:"
"`log` computes the natural logarithm (the base is *e*).  If a second "
"argument is provided, that value is used as the base."
msgstr ""

#: ../../source/math/index.rst
msgid "math_log.py"
msgstr ""

#: ../../source/math/index.rst:688
msgid "Logarithms where ``x`` is less than one yield negative results."
msgstr ""

#: ../../source/math/index.rst:704
msgid ""
"There are three variations of ``log()``.  Given floating point "
"representation and rounding errors, the computed value produced by "
"``log(x, b)`` has limited accuracy, especially for some bases. "
"``log10()`` computes ``log(x, 10)``, using a more accurate algorithm than"
" ``log()``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_log10.py"
msgstr ""

#: ../../source/math/index.rst:714
msgid ""
"The lines in the output with trailing ``*`` highlight the inaccurate "
"values."
msgstr ""

#: ../../source/math/index.rst:740
msgid ""
"There are two variations of :func:`log`.  Given floating point "
"representation and rounding errors the computed value produced by ``log(x, "
"b)`` has limited accuracy, especially for some bases. :func:`log10` computes "
"``log(x, 10)``, using a more accurate algorithm than :func:`log`."
msgstr ""

#: ../../source/math/index.rst:747
msgid ""
"Depending on the underlying platform, using the built-in and special-"
"purpose function can offer better performance and accuracy by using "
"special-purpose algorithms for base 2 that are not found in the more "
"general purpose function."
msgstr ""

#: ../../source/math/index.rst:775
msgid ""
"``log1p()`` calculates the Newton-Mercator series (the natural logarithm "
"of ``1+x``)."
msgstr ""

#: ../../source/math/index.rst
msgid "math_log1p.py"
msgstr ""

#: ../../source/math/index.rst:782
msgid ""
"``log1p()`` is more accurate for values of ``x`` very close to zero "
"because it uses an algorithm that compensates for round-off errors from "
"the initial addition."
msgstr ""

#: ../../source/math/index.rst:801
msgid "``exp()`` computes the exponential function (``e**x``)."
msgstr ""

#: ../../source/math/index.rst
msgid "math_exp.py"
msgstr ""

#: ../../source/math/index.rst:807
msgid ""
"As with other special-case functions, it uses an algorithm that produces "
"more accurate results than the general-purpose equivalent ``math.pow(math.e, "
"x)``."
msgstr ""

#: ../../source/math/index.rst:825
msgid "``expm1()`` is the inverse of ``log1p()``, and calculates ``e**x - 1``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_expm1.py"
msgstr ""

#: ../../source/math/index.rst:832
msgid ""
"Small values of ``x`` lose precision when the subtraction is performed "
"separately, like with ``log1p()``."
msgstr ""

#: ../../source/math/index.rst:850
msgid "Angles"
msgstr ""

#: ../../source/math/index.rst:852
msgid ""
"Although degrees are more commonly used in everyday discussions of angles, "
"radians are the standard unit of angular measure in science and math.  A "
"radian is the angle created by two lines intersecting at the center of a "
"circle, with their ends on the circumference of the circle spaced one radius "
"apart."
msgstr ""

#: ../../source/math/index.rst:858
msgid ""
"The circumference is calculated as ``2πr``, so there is a relationship "
"between radians and π, a value that shows up frequently in trigonometric "
"calculations.  That relationship leads to radians being used in trigonometry "
"and calculus, because they result in more compact formulas."
msgstr ""

#: ../../source/math/index.rst
msgid "math_radians.py"
msgstr ""

#: ../../source/math/index.rst:870
msgid "The formula for the conversion is ``rad = deg * π / 180``."
msgstr ""

#: ../../source/math/index.rst:893
msgid "To convert from radians to degrees, use ``degrees()``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_degrees.py"
msgstr ""

#: ../../source/math/index.rst:899
msgid "The formula is ``deg = rad * 180 / π``."
msgstr ""

#: ../../source/math/index.rst:924
msgid "Trigonometry"
msgstr ""

#: ../../source/math/index.rst:926
msgid ""
"Trigonometric functions relate angles in a triangle to the lengths of its "
"sides.  They show up in formulas with periodic properties such as harmonics, "
"circular motion, or when dealing with angles."
msgstr ""

#: ../../source/math/index.rst:932
msgid ""
"Given an angle in a right triangle, the *sine* is the ratio of the length"
" of the side opposite the angle to the hypotenuse (``sin A = "
"opposite/hypotenuse``).  The *cosine* is the ratio of the length of the "
"adjacent side to the hypotenuse (``cos A = adjacent/hypotenuse``). And "
"the *tangent* is the ratio of the opposite side to the adjacent side "
"(``tan A = opposite/adjacent``)."
msgstr ""

#: ../../PyMOTW/math/index.rst:752
msgid ""
"Given an angle in a right triangle, the *sine* is the ratio of the length of "
"the side opposite the angle to the hypotenuse (``sin A = opposite/"
"hypotenuse``).  The *cosine* is the ratio of the length of the adjacent side "
"to the hypotenuse (``cos A = adjacent/hypotenuse``). And the *tangent* is "
"the ratio of the opposite side to the adjacent side (``tan A = opposite/"
"adjacent``)."
msgstr ""

#: ../../source/math/index.rst:943
msgid ""
"The tangent can also be defined as the ratio of the sine of the angle to its "
"cosine, and since the cosine is 0 for π/2 and 3π/2 radians, the tangent is "
"infinite."
msgstr ""

#: ../../source/math/index.rst:973
msgid ""
"Given a point ``(x, y)``, the length of the hypotenuse for the triangle "
"between the points [(0, 0), (``x``, 0), (``x``, ``y``)] is ``(x**2 + "
"y**2) ** 1/2``, and can be computed with ``hypot()``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_hypot.py"
msgstr ""

#: ../../source/math/index.rst:981
msgid "Points on the circle always have hypotenuse equal to 1."
msgstr ""

#: ../../source/math/index.rst:1002
msgid "The same function can be used to find the distance between two points."
msgstr ""

#: ../../source/math/index.rst
msgid "math_distance_2_points.py"
msgstr ""

#: ../../source/math/index.rst:1008
msgid ""
"Use the difference in the ``x`` and ``y`` values to move one endpoint to "
"the origin, and then pass the results to ``hypot()``."
msgstr ""

#: ../../source/math/index.rst:1028
msgid "``math`` also defines inverse trigonometric functions."
msgstr ""

#: ../../source/math/index.rst
msgid "math_inverse_trig.py"
msgstr ""

#: ../../source/math/index.rst:1034
msgid ""
"``1.57`` is roughly equal to ``π/2``, or 90 degrees, the angle at which "
"the sine is 1 and the cosine is 0."
msgstr ""

#: ../../source/math/index.rst:1063
msgid "Hyperbolic Functions"
msgstr ""

#: ../../source/math/index.rst:1065
msgid ""
"Hyperbolic functions appear in linear differential equations and are used"
" when working with electromagnetic fields, fluid dynamics, special "
"relativity, and other advanced physics and mathematics."
msgstr ""

#: ../../source/math/index.rst
msgid "math_hyperbolic.py"
msgstr ""

#: ../../source/math/index.rst:1073
msgid ""
"Whereas the cosine and sine functions enscribe a circle, the hyperbolic "
"cosine and hyperbolic sine form half of a hyperbola."
msgstr ""

#: ../../source/math/index.rst:1095
msgid ""
"Inverse hyperbolic functions :func:`acosh`, :func:`asinh`, and :func:`atanh` "
"are also available."
msgstr ""

#: ../../source/math/index.rst:1099
msgid "Special Functions"
msgstr ""

#: ../../source/math/index.rst:1101
msgid "The Gauss Error function is used in statistics."
msgstr ""

#: ../../source/math/index.rst
msgid "math_erf.py"
msgstr ""

#: ../../source/math/index.rst:1107
msgid "For the error function, ``erf(-x) == -erf(x)``."
msgstr ""

#: ../../source/math/index.rst:1133
msgid "The complimentary error function is ``1 - erf(x)``."
msgstr ""

#: ../../source/math/index.rst
msgid "math_erfc.py"
msgstr ""

#: ../../source/math/index.rst:1139
msgid ""
"`IEEE floating point arithmetic in Python <http://www.johndcook.com/"
"blog/2009/07/21/ieee-arithmetic-python/>`__"
msgstr ""

#: ../../source/math/index.rst:1171
msgid ""
"`IEEE floating point arithmetic in Python "
"<http://www.johndcook.com/blog/2009/07/21/ieee-arithmetic-python/>`__ -- "
"Blog post by John Cook about how special values arise and are dealt with "
"when doing math in Python."
msgstr ""

#: ../../source/math/index.rst:1176
msgid ""
"`SciPy <http://scipy.org/>`_ -- Open source libraryes for scientific and "
"mathematical calculations in Python."
msgstr ""

#: ../../PyMOTW/math/index.rst:994
msgid ""
"Open source libraryes for scientific and mathematical calculations in Python."
msgstr ""

