#
msgid ""
msgstr ""
"Project-Id-Version: Python Module of the Week 2.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 13:35-0300\n"
"PO-Revision-Date: 2015-11-04 18:31-0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: es_AR\n"
"X-Generator: Poedit 1.8.6\n"

#: ../../PyMOTW/asynchat/index.rst:3
msgid "asynchat -- Asynchronous protocol handler"
msgstr "asynchat -- Controlador de protocolo asincrónico "

#: ../../PyMOTW/asynchat/index.rst:8
msgid "Asynchronous network communication protocol handler"
msgstr "Controlador de protocolo de comunicación asincrónica de red"

#: ../../PyMOTW/asynchat/index.rst:9
msgid "1.5.2 and later"
msgstr "1.5.2 y posterior"

#: ../../PyMOTW/asynchat/index.rst:11
msgid ""
"The :mod:`asynchat` module builds on :mod:`asyncore` to make it easier to "
"implement protocols based on passing messages back and forth between server "
"and client. The :class:`async_chat` class is an :class:`asyncore."
"dispatcher` subclass that receives data and looks for a message terminator. "
"Your subclass only needs to specify what to do when data comes in and how "
"to respond once the terminator is found. Outgoing data is queued for "
"transmission via FIFO objects managed by :class:`async_chat`."
msgstr ""
"El modulo :mod:`asynchat` se basa en :mod:`asyncore` para que sea mas fácil "
"de implementar protocolos basados en pasar mensajes de ida y vuelta entre "
"servidor y cliente. La clase :class:`async_chat` es una subclase de :class:"
"`asyncore.dispatcher`  que recibe datos y busca una terminación de mensaje. "
"Su subclase solo necesita especificar que hacer cuando los datos y como "
"responder una vez que el adaptador se encuentra. La salida de datos es "
"puesta en cola de transmisión a través de objetos FIFO manejados por :class:"
"`async_chat`."

#: ../../PyMOTW/asynchat/index.rst:21
msgid "Message Terminators"
msgstr "Terminador de mensaje"

#: ../../PyMOTW/asynchat/index.rst:23
msgid ""
"Incoming messages are broken up based on *terminators*, controlled for each "
"instance via :func:`set_terminator()`. There are three possible "
"configurations:"
msgstr ""
"Los mensajes entrantes se dividen en base a *terminaciones*, controlado "
"para cada instancia a través de :func:`set_terminator()`. Hay tres "
"configuraciones posibles:"

#: ../../PyMOTW/asynchat/index.rst:27
msgid ""
"If a string argument is passed to :func:`set_terminator()`, the message is "
"considered complete when that string appears in the input data."
msgstr ""
"Si un argumento de cadena se pasa a :func:`set_terminator()`, el mensaje es "
"considerado completo cuando la cadena aparece en los datos de entrada."

#: ../../PyMOTW/asynchat/index.rst:30
msgid ""
"If a numeric argument is passed, the message is considered complete when "
"that many bytes have been read."
msgstr ""
"Si se pasa un argumento numérico, el mensaje es considerado completo cuando "
"un número de bytes ha sido leído.-"

#: ../../PyMOTW/asynchat/index.rst:32
msgid ""
"If ``None`` is passed, message termination is not managed by :class:"
"`async_chat`."
msgstr ""
"Si es pasado ``None``, la terminación del mensaje no es manejada por :class:"
"`async_chat`."

#: ../../PyMOTW/asynchat/index.rst:35
msgid ""
"The :class:`EchoServer` example below uses both a simple string terminator "
"and a message length terminator, depending on the context of the incoming "
"data. The HTTP request handler example in the standard library "
"documentation offers another example of how to change the terminator based "
"on the context to differentiate between HTTP headers and the HTTP POST "
"request body."
msgstr ""
"El ejemplo siguiente de :class:`EchoServer`  utiliza un terminador de "
"cadena simple y un terminador de la longitud de mensaje, dependiendo del "
"contexto de los datos entrantes. El ejemplo de controlador de solicitud "
"HTTP en la documentación de la biblioteca estándar ofrece otro ejemplo de "
"como cambiar el terminador en función del contexto para distinguir entre "
"las cabeceras HTTP y el cuerpo de la soliciutd HTTP POST."

#: ../../PyMOTW/asynchat/index.rst:43
msgid "Server and Handler"
msgstr "Servidor y manejador"

#: ../../PyMOTW/asynchat/index.rst:45
msgid ""
"To make it easier to understand how :mod:`asynchat` is different from :mod:"
"`asyncore`, the examples here duplicate the functionality of the :class:"
"`EchoServer` example from the :mod:`asyncore` discussion. The same pieces "
"are needed: a server object to accept connections, handler objects to deal "
"with communication with each client, and client objects to initiate the "
"conversation."
msgstr ""
"Para que sea más fácil de entender cómo :mod:`asynchat` es diferente de :"
"mod:`asyncore`, los ejemplos aquí duplican la funcionalidad de la :class:"
"`EchoServer` ejemplo del :mod:`asyncore`. Se necesitan las mismas piezas: "
"un objeto de servidor que acepte conexiones, manejador de objetos para "
"hacer frente a la comunicación con cada cliente, y un objeto cliente que "
"inicia la conversación."

#: ../../PyMOTW/asynchat/index.rst:52
msgid ""
"The :class:`EchoServer` needed to work with :mod:`asynchat` is essentially "
"the same as the one created for the :mod:`asyncore` example, with fewer :"
"mod:`logging` calls because they are less interesting this time around:"
msgstr ""
"La :class: `EchoServer` necesaria para trabajar con :mod:`asynchat` es "
"esencialmente la mismo que el creado por el ejemplo :mod: `asyncore`, con "
"menos llamada a :mod:` logging` porque son menos interesante en esta "
"ocasión:"

#: ../../PyMOTW/asynchat/index.rst:61
msgid ""
"The :class:`EchoHandler` is based on ``asynchat.async_chat`` instead of "
"the :class:`asyncore.dispatcher` this time around. It operates at a "
"slightly higher level of abstraction, so reading and writing are handled "
"automatically. The buffer needs to know four things:"
msgstr ""
"La :class:`EchoHandler` se basa en``asynchat.async_chat`` en lugar de :"
"class:`asyncore.dispatcher` en esta ocasión. Opera a un nivel ligeramente "
"más alto de abstracción, por lo que la lectura y la escritura son manejados "
"automáticamente. El buffer necesita saber cuatro cosas:"

#: ../../PyMOTW/asynchat/index.rst:66
msgid ""
"what to do with incoming data (by overriding :func:`handle_incoming_data()`)"
msgstr ""
"qué hacer con los datos de entrada (por razones imperiosas :func:"
"`handle_incoming_data ()`)"

#: ../../PyMOTW/asynchat/index.rst:68
msgid ""
"how to recognize the end of an incoming message (via :func:"
"`set_terminator()`)"
msgstr ""
"cómo reconocer el final de un mensaje entrante (a través de :func:"
"`set_terminator ()`)"

#: ../../PyMOTW/asynchat/index.rst:70
msgid ""
"what to do when a complete message is received (in :func:"
"`found_terminator()`)"
msgstr ""
"qué hacer cuando se recibe un mensaje completo (en :func:`found_terminator "
"()`)"

#: ../../PyMOTW/asynchat/index.rst:72
msgid "what data to send (using :func:`push()`)"
msgstr "qué datos para enviar (usando :func:`push()`)"

#: ../../PyMOTW/asynchat/index.rst:74
msgid ""
"The example application has two operating modes. It is either waiting for a "
"command of the form ``ECHO length\\n``, or waiting for the data to be "
"echoed. The mode is toggled back and forth by setting an instance variable "
"*process_data* to the method to be invoked when the terminator is found and "
"then changing the terminator as appropriate."
msgstr ""
"La aplicación de ejemplo tiene dos modos de funcionamiento. O bien está "
"esperando un comando de la forma ``longitud ECHO \\n``, o en espera de los "
"datos que se hicieron eco. El modo se puede cambiar entre una y otra "
"mediante el establecimiento de una variable de instancia *process_data* con "
"el método que se invoca cuando se encuentra el terminador y luego cambiar "
"el terminador según corresponda."

#: ../../PyMOTW/asynchat/index.rst:84
msgid ""
"Once the complete command is found, the handler switches to message-"
"processing mode and waits for the complete set of text to be received. When "
"all of the data is available, it is pushed onto the outgoing channel and "
"set up the handler to be closed once the data is sent."
msgstr ""
"Una vez encontrado el comando completo, el controlador cambia al modo de "
"procesamiento de mensaje y espera a recibir el conjunto completo de texto. "
"Cuando todos los datos están disponibles, se inserta en el canal de salida "
"y se configura el controlador que se cierre una vez que se envían los datos."

#: ../../PyMOTW/asynchat/index.rst:91
msgid "Client"
msgstr "Cliente"

#: ../../PyMOTW/asynchat/index.rst:93
msgid ""
"The client works in much the same way as the handler. As with the :mod:"
"`asyncore` implementation, the message to be sent is an argument to the "
"client's constructor. When the socket connection is established, :func:"
"`handle_connect()` is called so the client can send the command and message "
"data."
msgstr ""
"El cliente funciona de la misma manera como el controlador. Al igual que "
"con el :mod:`aplicación asyncore`, el mensaje que se enviará es un "
"argumento para el constructor del cliente. Cuando se establece la conexión "
"de socket,:func: `handle_connect()` es llamado por lo que el cliente puede "
"enviar los datos de comando y de mensajes."

#: ../../PyMOTW/asynchat/index.rst:99
msgid ""
"The command is pushed directly, but a special \"producer\" class is used "
"for the message text. The producer is polled for chunks of data to send out "
"over the network. When the producer returns an empty string, it is assumed "
"to be empty and writing stops."
msgstr ""
"El comando se empuja directamente, pero a una clase especial de \"productor"
"\" se utiliza para el texto del mensaje. El productor se sondea para "
"fragmentos de datos para enviar por la red. Cuando el productor devuelve "
"una cadena vacía, se supone se vacía y se escriben paradas."

#: ../../PyMOTW/asynchat/index.rst:104
msgid ""
"The client expects just the message data in response, so it sets an integer "
"terminator and collects data in a list until the entire message has been "
"received."
msgstr ""
"El cliente espera que sólo los datos del mensaje de respuesta, por lo que "
"establece un terminador entero y recoge datos en una lista hasta que se ha "
"recibido el mensaje completo."

#: ../../PyMOTW/asynchat/index.rst:114
msgid "Putting It All Together"
msgstr "Poniendo todo junto"

#: ../../PyMOTW/asynchat/index.rst:116
msgid ""
"The main program for this example sets up the client and server in the "
"same :mod:`asyncore` main loop."
msgstr ""
"El programa principal para este ejemplo configura el cliente y el servidor "
"en el mismo :mod:`asyncore` bucle principal."

#: ../../PyMOTW/asynchat/index.rst:123
msgid ""
"Normally you would have them in separate processes, but this makes it "
"easier to show the combined output."
msgstr ""
"Normalmente te gustaría tenerlos en procesos separados, pero esto hace que "
"sea más fácil para mostrar la salida combinada."

#: ../../PyMOTW/asynchat/index.rst:157
msgid "`asynchat <http://docs.python.org/library/asynchat.html>`_"
msgstr "`asynchat <http://docs.python.org/library/asynchat.html>`_"

#: ../../PyMOTW/asynchat/index.rst:157
msgid "The standard library documentation for this module."
msgstr "La documentación de la biblioteca estándar para este módulo."

#: ../../PyMOTW/asynchat/index.rst:160
msgid ":mod:`asyncore`"
msgstr ":mod:`asyncore`"

#: ../../PyMOTW/asynchat/index.rst:160
msgid ""
"The asyncore module implements an lower-level asynchronous I/O event loop."
msgstr ""
"El módulo asyncore implementa un bucle de eventos asíncrono de E/S de nivel "
"inferior."
